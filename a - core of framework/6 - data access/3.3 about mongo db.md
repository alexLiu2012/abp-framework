## about mongodb

相关程序集

* Volo.Abp.MongoDb

----

### 1. about

#### 1.1 summary

* abp框架集成了 mongodb

#### 1.2 how designed

##### 1.2.1 声明（注册）mongodb

###### 1.2.1.1 abp mongo dbContext registration options

* 继承 common dbContext register options

###### 1.2.1.2 mongodb repository registrar

* 继承 repo register base 并实现功能
  * get entity types
  * get repo type

###### 1.2.1.3 add mongodb(Context)

* 扩展 services 的 add mongo dbContext 方法
  * 配置 mongo dbContext registration options
  * 调用 mongodb repo registrar 的 addRepositories 方法

##### 1.2.2 mongodb repo

* IRepo 在 mongodb 下的实现

* crud、event 等操作通过内部包含的：

  * mongo database、mongo collection（mongodb driver 组件）

  实现

* 上述组件由 mongo dbContext 解析

##### 1.2.3 mongodb dbContext

###### 1.2.3.1 mongo dbContext

* mongodb 的抽象映射
* 解耦 repo 和 mongodb
* 解析 mongo database
* 定义数据库模型
  * 填充 mongodb collection
  * 配置 mongodb collection map

###### 1.2.3.2 mongodb dbContext model

* mongodb database 的概念，对应的 object model（数据库模型）
* 由 mongodb model builder 构建（build）

###### 1.2.3.3 mongodb model source

* 管理 mongodb dbContext model 的服务
* 缓存 mongodb dbContext model

###### 1.2.3.4 mongodb entity model

* mongodb collection 的概念，对应的 entity model（数据表模型）
* 由 mongodb entity model builder 构建

##### 1.2.4 mongo dbContext provider

* 获取、创建 mongo dbContext
* 管理器

### 2. details

#### 2.1 注册 mongodb

* 实现 mongodb repo 自动注册

##### 2.1.1 mongo dbContext registration options 

###### 2.1.1.1 接口

```c#
public interface IAbpMongoDbContextRegistrationOptionsBuilder :
	IAbpCommonDbContextRegistrationOptionsBuilder
{    
}

```

###### 2.1.1.2 实现

```c#
public class AbpMongoDbContextRegistrationOptions : 
	AbpCommonDbContextRegistrationOptions, 
	IAbpMongoDbContextRegistrationOptionsBuilder
{
    public AbpMongoDbContextRegistrationOptions(
        Type originalDbContextType, 
        IServiceCollection services)             
        	: base(originalDbContextType, services)
    {
    }
}

```

##### 2.1.2 mongo repo register

```c#
public class MongoDbRepositoryRegistrar :
	RepositoryRegistrarBase<AbpMongoDbContextRegistrationOptions>
{
    public MongoDbRepositoryRegistrar(
        AbpMongoDbContextRegistrationOptions options) 
        	: base(options)
    {        
    }
    
    // 重写（实现）get entity types 方法，
    // 通过 mongo dbContext helper 实现
    protected override IEnumerable<Type> GetEntityTypes(Type dbContextType)
    {
        return MongoDbContextHelper
            .GetEntityTypes(dbContextType);
    }
    // 重写（实现）get repo type，
    // 为 entity 创建 mongoDbRepo<TContext,TEntity>
    protected override Type GetRepositoryType(
        Type dbContextType, 
        Type entityType)
    {
        return typeof(MongoDbRepository<,>)
            .MakeGenericType(dbContextType, entityType);
    }
    // 重写（实现）get repo type，
    // 为 entity 创建 mongoDbRepo<TContext,TEntity,TKey>
    protected override Type GetRepositoryType(
        Type dbContextType, 
        Type entityType, 
        Type primaryKeyType)
    {
        return typeof(MongoDbRepository<,,>)
            .MakeGenericType(dbContextType, entityType, primaryKeyType);
    }
}

```

##### 2.1.3 mongo dbContext helper

* 工具类，获取 mongo dbContext 中定义的需要注册 repo 的 entity 类型
* 对于 mongodb 来说，
  * 就是 IMongoCollection<T> 的泛型类型 T
  * 并且实现 IEntity 接口

```c#
internal static class MongoDbContextHelper
{
    public static IEnumerable<Type> GetEntityTypes(Type dbContextType)
    {
        return
            // 获取 mongoDbContext 中的 
            // public、instance 的属性
            from property in 
            	dbContextType.GetTypeInfo().GetProperties(
            		BindingFlags.Public | 
            		BindingFlags.Instance)            
            where
            	// 实现了 IMongoCollection<T> 的属性
            	ReflectionHelper.IsAssignableToGenericType(
            		property.PropertyType, 
            		typeof(IMongoCollection<>)) &&
            	// T 的类型是 IEntity
                typeof(IEntity).IsAssignableFrom(
            		property.PropertyType.GenericTypeArguments[0])
            // 返回 T
            select property.PropertyType.GenericTypeArguments[0];
    }
}

```

##### 2.1.4 add mongo db(Context)

* services 的扩展方法，声明使用 mongoDb(Context)
  * 配置 abp mongo dbContext registration options
  * 调用 mongodb repo registrar 的`AddRepositories()`方法，用于注册 IRepo 在 mongoDb 的实现

```c#
public static class AbpMongoDbServiceCollectionExtensions
{
    public static IServiceCollection 
        AddMongoDbContext<TMongoDbContext>(
        	this IServiceCollection services,
        	Action<IAbpMongoDbContextRegistrationOptionsBuilder> 
        		optionsBuilder = null)         	       
       	where TMongoDbContext : AbpMongoDbContext
    {
        // 创建 abp mongo dbContext registration options
        var options = new AbpMongoDbContextRegistrationOptions(
            typeof(TMongoDbContext), 
            services);
        // 配置 abp mongo dbContext registration options
        optionsBuilder?.Invoke(options);
        
        // 保证 options.DefaultRepositoryDbContextType 是 TMongoDbContext
        // ？？？
            
        // 注册 TMongoDbContext，
        // 并替换 options.ReplacedDbContextType
        foreach (var dbContextType in options.ReplacedDbContextTypes)
        {
            services.Replace(
                ServiceDescriptor.Transient(
                    dbContextType, 
                    typeof(TMongoDbContext)));
        }
        
        // 创建 mongodb repo registrar 并加载 repos
        new MongoDbRepositoryRegistrar(options).AddRepositories();
        
        return services;
    }
}

```

#### 2.2 mongo repo

* IRepo 在 mongodb 下的实现

##### 2.2.1 IMongoDbRepository 接口

```c#
// mongodb repo <entity>
public interface IMongoDbRepository<TEntity> : 
	IRepository<TEntity>        
        where TEntity : class, IEntity
{    
    // mongodb driver 组件，
    // 实现 mongodb 读写
    IMongoDatabase Database { get; }    
    IMongoCollection<TEntity> Collection { get; }    
            
    IMongoQueryable<TEntity> GetMongoQueryable();
}

// mongodb repo <entity, key>
public interface IMongoDbRepository<TEntity, TKey> : 
	IMongoDbRepository<TEntity>, IRepository<TEntity, TKey>        
        where TEntity : class, IEntity<TKey>
{    
}

```

##### 2.2.2 MongoDbRepository(TEntity)

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> : 
	RepositoryBase<TEntity>,
	IMongoDbRepository<TEntity>,        
	IMongoQueryable<TEntity>        
        where TMongoDbContext : IAbpMongoDbContext        
        where TEntity : class, IEntity
{
    // 从 TMongoDbContext 解析
    public virtual IMongoCollection<TEntity> Collection => 
        DbContext.Collection<TEntity>();    
    public virtual IMongoDatabase Database => 
        DbContext.Database;    
    public virtual IClientSessionHandle SessionHandle => 
        DbContext.SessionHandle;
              
    // 从 mongoDbContextProvider 解析 TMongoDbContext
    public virtual TMongoDbContext DbContext => 
        DbContextProvider.GetDbContext();               
    protected IMongoDbContextProvider<TMongoDbContext> DbContextProvider { get; }
    
    public ILocalEventBus LocalEventBus { get; set; }    
    public IDistributedEventBus DistributedEventBus { get; set; }
    
    public IEntityChangeEventHelper EntityChangeEventHelper { get; set; }   
    public IAuditPropertySetter AuditPropertySetter { get; set; }
    public IGuidGenerator GuidGenerator { get; set; }    
        
    public MongoDbRepository(
        IMongoDbContextProvider<TMongoDbContext> dbContextProvider)
    {
        // 注入 mongoDbContextProvider
        DbContextProvider = dbContextProvider;
        
        // 属性注入 localEventBus、distributedEventBus、entityChangeHelper
        LocalEventBus = NullLocalEventBus.Instance;
        DistributedEventBus = NullDistributedEventBus.Instance;
        EntityChangeEventHelper = NullEntityChangeEventHelper.Instance;
        
        // 创建 id generator
        GuidGenerator = SimpleGuidGenerator.Instance;
    }
                        
    /* get queryable */               
    protected override IQueryable<TEntity> GetQueryable()
    {
        return GetMongoQueryable();
    }            
    public virtual IMongoQueryable<TEntity> GetMongoQueryable()
    {
        return ApplyDataFilters(
            SessionHandle != null 
            	? Collection.AsQueryable(SessionHandle) 
            	: Collection.AsQueryable());
    }
                                                                                        
    /// <summary>
    /// IMongoQueryable<TEntity>
    /// </summary>
    /// <returns></returns>
    public QueryableExecutionModel GetExecutionModel()
    {
        return GetMongoQueryable().GetExecutionModel();
    }
    
    /// <summary>
    /// IMongoQueryable<TEntity>
    /// </summary>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    public IAsyncCursor<TEntity> ToCursor(
        CancellationToken cancellationToken = new CancellationToken())
    {
        return GetMongoQueryable().ToCursor(cancellationToken);
    }
    
    /// <summary>
    /// IMongoQueryable<TEntity>
    /// </summary>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    public Task<IAsyncCursor<TEntity>> ToCursorAsync(
        CancellationToken cancellationToken = new CancellationToken())
    {
        return GetMongoQueryable().ToCursorAsync(cancellationToken);
    }                  
}

```

###### 2.2.2.1 trigger domain events

* 触发 domain event

* entity 必须实现`IGeneratesDomainEvents`接口

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{
    protected virtual async Task TriggerDomainEventsAsync(object entity)
    {
        var generatesDomainEventsEntity = entity as IGeneratesDomainEvents;
        
        // 如果没有实现 IGeneratesDomainEvent，忽略
        if (generatesDomainEventsEntity == null)
        {
            return;
        }
        
        // 发布 local event
        var localEvents = generatesDomainEventsEntity
            .GetLocalEvents()?.ToArray();
        if (localEvents != null && localEvents.Any())
        {
            // 发布
            foreach (var localEvent in localEvents)
            {
                await LocalEventBus
                    .PublishAsync(
                    	localEvent.GetType(), 
                    	localEvent);
            }
            // 发布后清空（local event 容器）
            generatesDomainEventsEntity.ClearLocalEvents();
        }
        
        // 发布 distributed event
        var distributedEvents = generatesDomainEventsEntity
            .GetDistributedEvents()?.ToArray();
        if (distributedEvents != null && distributedEvents.Any())
        {
            // 发布
            foreach (var distributedEvent in distributedEvents)
            {
                await DistributedEventBus
                    .PublishAsync(
                    	distributedEvent.GetType(), 
                    	distributedEvent);
            }
            // 发布后清空（distributed event 容器）
            generatesDomainEventsEntity.ClearDistributedEvents();
        }
    }
}

```

###### 2.2.2.2 create entity filter

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{                   
    protected virtual FilterDefinition<TEntity> CreateEntityFilter(
        TEntity entity, 
        bool withConcurrencyStamp = false, 
        string concurrencyStamp = null)
    {
        throw new NotImplementedException(
            $"{nameof(CreateEntityFilter)} is not implemented for MongoDB by default. It should be overriden and implemented by the deriving class!");
    }
}

```

###### 2.2.2.3 insert

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{
    public async override Task<TEntity> InsertAsync(
        TEntity entity,
        bool autoSave = false,
        CancellationToken cancellationToken = default)
    {
        await ApplyAbpConceptsForAddedEntityAsync(entity);
        
        if (SessionHandle != null)
        {
            await Collection.InsertOneAsync(
                SessionHandle,
                entity,
                cancellationToken: 
                	GetCancellationToken(cancellationToken));
        }
        else
        {
            await Collection.InsertOneAsync(
                entity,
                cancellationToken: 
                	GetCancellationToken(cancellationToken));
        }
        
        return entity;
    }
    
    /* abp concept of added entity */
    
    protected virtual async Task ApplyAbpConceptsForAddedEntityAsync(TEntity entity)
    {
        CheckAndSetId(entity);
        SetCreationAuditProperties(entity);
        await TriggerEntityCreateEvents(entity);
        await TriggerDomainEventsAsync(entity);
    }
        
    protected virtual void CheckAndSetId(TEntity entity)
    {
        if (entity is IEntity<Guid> entityWithGuidId)
        {
            TrySetGuidId(entityWithGuidId);
        }
    }    
        
    protected virtual void TrySetGuidId(IEntity<Guid> entity)
    {
        // 如果 id 不为 default，即设置过 id，忽略
        if (entity.Id != default)
        {
            return;
        }
        
        EntityHelper.TrySetId(
            entity,
            () => GuidGenerator.Create(),
            true);
    }      
        
    protected virtual void SetCreationAuditProperties(TEntity entity)
    {
        AuditPropertySetter.SetCreationProperties(entity);
    }
        
    private async Task TriggerEntityCreateEvents(TEntity entity)
    {
        await EntityChangeEventHelper
            .TriggerEntityCreatedEventOnUowCompletedAsync(entity);
        await EntityChangeEventHelper
            .TriggerEntityCreatingEventAsync(entity);
    }        
}

```

###### 2.2.2.4 delete

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{      
    // 删除 specific entity
    public async override Task DeleteAsync(
        TEntity entity,
        bool autoSave = false,
        CancellationToken cancellationToken = default)
    {
        await ApplyAbpConceptsForDeletedEntityAsync(entity);
        var oldConcurrencyStamp = SetNewConcurrencyStamp(entity);
        
        // 如果支持 soft delete（实现 ISoftDelete 接口），
        // 不是 hard delete
        if (entity is ISoftDelete softDeleteEntity && 
            !IsHardDeleted(entity))
        {
            softDeleteEntity.IsDeleted = true;
            ReplaceOneResult result;
            
            if (SessionHandle != null)
            {
                result = await Collection.ReplaceOneAsync(
                    SessionHandle,
                    CreateEntityFilter(
                        entity, true, oldConcurrencyStamp),
                    entity,
                    cancellationToken: 
                    	GetCancellationToken(cancellationToken));
            }
            else
            {
                result = await Collection.ReplaceOneAsync(
                    CreateEntityFilter(
                        entity, true, oldConcurrencyStamp),
                    entity,
                    cancellationToken:
                    	GetCancellationToken(cancellationToken));
            }
            
            if (result.MatchedCount <= 0)
            {
                ThrowOptimisticConcurrencyException();
            }
        }
        // 不支持 soft delete，直接删除
        else
        {
            DeleteResult result;
            
            if (SessionHandle != null)
            {
                result = await Collection.DeleteOneAsync(
                    SessionHandle,
                    CreateEntityFilter(
                        entity, true, oldConcurrencyStamp),
                    cancellationToken: 
                    	GetCancellationToken(cancellationToken));
            }
            else
            {
                result = await Collection.DeleteOneAsync(
                    CreateEntityFilter(
                        entity, true, oldConcurrencyStamp),
                    GetCancellationToken(cancellationToken));
            }
            
            if (result.DeletedCount <= 0)
            {
                ThrowOptimisticConcurrencyException();
            }
        }
    }
    
    // 过滤删除
    public async override Task DeleteAsync(
        Expression<Func<TEntity, bool>> predicate,
        bool autoSave = false,
        CancellationToken cancellationToken = default)
    {
        var entities = await GetMongoQueryable()
            .Where(predicate)
            .ToListAsync(GetCancellationToken(cancellationToken));
        
        foreach (var entity in entities)
        {
            await DeleteAsync(entity, autoSave, cancellationToken);
        }
    }
    
    /* is hard deleted */ 
    
    protected virtual bool IsHardDeleted(TEntity entity)
    {
        var hardDeletedEntities = UnitOfWorkManager?.Current?.Items
            .GetOrDefault(UnitOfWorkItemNames.HardDeletedEntities) 
            	as HashSet<IEntity>;
        
        if (hardDeletedEntities == null)
        {
            return false;
        }
        
        return hardDeletedEntities.Contains(entity);
    }
    
    /* concurrent stamp */
    
    /// <summary>
    /// Sets a new <see cref="IHasConcurrencyStamp.ConcurrencyStamp"/> value
    /// if given entity implements <see cref="IHasConcurrencyStamp"/> interface.
    /// Returns the old <see cref="IHasConcurrencyStamp.ConcurrencyStamp"/> value.
    /// </summary>
    protected virtual string SetNewConcurrencyStamp(TEntity entity)
    {
        if (!(entity is IHasConcurrencyStamp concurrencyStampEntity))
        {
            return null;
        }
        
        var oldConcurrencyStamp = concurrencyStampEntity.ConcurrencyStamp;
        concurrencyStampEntity.ConcurrencyStamp = Guid.NewGuid().ToString("N");
        
        return oldConcurrencyStamp;
    }
    
    protected virtual void ThrowOptimisticConcurrencyException()
    {
        throw new AbpDbConcurrencyException("Database operation expected to affect 1 row but actually affected 0 row. Data may have been modified or deleted since entities were loaded. This exception has been thrown on optimistic concurrency check.");
    }
    
    /* abp concept of deleted entity */
    
    protected virtual async Task ApplyAbpConceptsForDeletedEntityAsync(TEntity entity)
    {
        SetDeletionAuditProperties(entity);
        await TriggerEntityDeleteEventsAsync(entity);
        await TriggerDomainEventsAsync(entity);
    }
    
    protected virtual void SetDeletionAuditProperties(TEntity entity)
    {
        AuditPropertySetter.SetDeletionProperties(entity);
    }
    
    protected virtual async Task TriggerEntityDeleteEventsAsync(TEntity entity)
    {
        await EntityChangeEventHelper
            .TriggerEntityDeletedEventOnUowCompletedAsync(entity);
        await EntityChangeEventHelper
            .TriggerEntityDeletingEventAsync(entity);
    }
}

```

###### 2.2.2.5 update

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{
    public async override Task<TEntity> UpdateAsync(
        TEntity entity,
        bool autoSave = false,
        CancellationToken cancellationToken = default)
    {
        SetModificationAuditProperties(entity);
        
        // 如果被标记为 soft deleted
        if (entity is ISoftDelete softDeleteEntity && 
            softDeleteEntity.IsDeleted)
        {
            SetDeletionAuditProperties(entity);
            await TriggerEntityDeleteEventsAsync(entity);
        }
        else
        {
            await TriggerEntityUpdateEventsAsync(entity);
        }
        
        await TriggerDomainEventsAsync(entity);
        
        /* 更新 entity */
        var oldConcurrencyStamp = SetNewConcurrencyStamp(entity);
        ReplaceOneResult result;
        
        if (SessionHandle != null)
        {
            result = await Collection.ReplaceOneAsync(
                SessionHandle,
                CreateEntityFilter(
                    entity, true, oldConcurrencyStamp),
                entity,
                cancellationToken: 
                	GetCancellationToken(cancellationToken));       
        }
        else
        {
            result = await Collection.ReplaceOneAsync(
                CreateEntityFilter(
                    entity, true, oldConcurrencyStamp),
                entity,
                cancellationToken: 
                	GetCancellationToken(cancellationToken));
        }
        
        if (result.MatchedCount <= 0)
        {
            ThrowOptimisticConcurrencyException();
        }
        
        return entity;
    }	
    
    /* abp concept of updated entity */
    
    protected virtual void SetModificationAuditProperties(TEntity entity)
    {
        AuditPropertySetter.SetModificationProperties(entity);
    }
    
    protected virtual async Task TriggerEntityUpdateEventsAsync(TEntity entity)
    {
        await EntityChangeEventHelper
            .TriggerEntityUpdatedEventOnUowCompletedAsync(entity);
        await EntityChangeEventHelper
            .TriggerEntityUpdatingEventAsync(entity);
    }                                        
}

```

###### 2.2.2.6 find

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{
    public async override Task<TEntity> FindAsync(
        Expression<Func<TEntity, bool>> predicate,
        bool includeDetails = true,
        CancellationToken cancellationToken = default)
    {
        return await GetMongoQueryable()
            .Where(predicate)
            .SingleOrDefaultAsync(
            	GetCancellationToken(cancellationToken));
    }
}

```

###### 2.2.2.7 get list

```c#
public class MongoDbRepository<TMongoDbContext, TEntity> 
{
    // get list 
    public async override Task<List<TEntity>> GetListAsync(
         bool includeDetails = false, 
         CancellationToken cancellationToken = default)
    {
        return await GetMongoQueryable()
            .ToListAsync(
            	GetCancellationToken(cancellationToken));
    }
    // get count
    public async override Task<long> GetCountAsync(
        CancellationToken cancellationToken = default)
    {
        return await GetMongoQueryable()
            .LongCountAsync(
            	GetCancellationToken(cancellationToken));
    }
    // get paged list
    public async override Task<List<TEntity>> GetPagedListAsync(
        int skipCount,
        int maxResultCount,
        string sorting,
        bool includeDetails = false,
        CancellationToken cancellationToken = default)
    {
        return await GetMongoQueryable()
            .OrderBy(sorting)
            .As<IMongoQueryable<TEntity>>()
            .PageBy<TEntity, IMongoQueryable<TEntity>>(
            	skipCount, maxResultCount)
            .ToListAsync(
            	GetCancellationToken(cancellationToken));
    }
}

```

##### 2.2.3 MongoDbRepository(TEntity, TKey)

```c#
public class MongoDbRepository<TMongoDbContext, TEntity, TKey> : 
	MongoDbRepository<TMongoDbContext, TEntity>,        
	IMongoDbRepository<TEntity, TKey>        
        where TMongoDbContext : IAbpMongoDbContext        
        where TEntity : class, IEntity<TKey>
{
    public IMongoDbRepositoryFilterer<TEntity, TKey> 
        RepositoryFilterer { get; set; }    
            
    public MongoDbRepository(
        IMongoDbContextProvider<TMongoDbContext> dbContextProvider)   
        	: base(dbContextProvider)
    {        
    }                                
}

```

###### 2.2.3.1 create entity filter

```c#
public class MongoDbRepository<TMongoDbContext, TEntity, TKey>      
{
    protected override FilterDefinition<TEntity> CreateEntityFilter(
        TEntity entity, 
        bool withConcurrencyStamp = false, 
        string concurrencyStamp = null)
    {
        return RepositoryFilterer.CreateEntityFilter(
            entity, 
            withConcurrencyStamp, 
            concurrencyStamp);
    }
}

```

###### 2.2.3.1 delete

```c#
public class MongoDbRepository<TMongoDbContext, TEntity, TKey>      
{
    public virtual Task DeleteAsync(            
        TKey id,            
        bool autoSave = false,            
        CancellationToken cancellationToken = default)
    {
        return DeleteAsync(
            x => x.Id.Equals(id), autoSave, cancellationToken);
    }
}

```

###### 2.2.3.2 find

```c#
public class MongoDbRepository<TMongoDbContext, TEntity, TKey>      
{
    public virtual async Task<TEntity> FindAsync(            
        TKey id,            
        bool includeDetails = true,            
        CancellationToken cancellationToken = default)
    {
        if (SessionHandle != null)
        {
            return await Collection
                .Find(
                	SessionHandle, 
                	RepositoryFilterer.CreateEntityFilter(id, true))
                .FirstOrDefaultAsync(
                	GetCancellationToken(cancellationToken));
        }
        
        return await Collection
            .Find(RepositoryFilterer.CreateEntityFilter(id, true))
            .FirstOrDefaultAsync(
            	GetCancellationToken(cancellationToken));
    }
}

```

###### 2.2.3.3 get

```c#
public class MongoDbRepository<TMongoDbContext, TEntity, TKey>      
{
    public virtual async Task<TEntity> GetAsync(        
        TKey id,            
        bool includeDetails = true,            
        CancellationToken cancellationToken = default)
    {
        var entity = await FindAsync(
            id, 
            includeDetails, 
            cancellationToken);
        
        if (entity == null)
        {
            throw new EntityNotFoundException(typeof(TEntity), id);
        }
        
        return entity;
    }
}

```

##### 2.2.4 mongodb repo filter

###### 2.2.4.1 IMongoDbRepositoryFilter 接口

```c#
public interface IMongoDbRepositoryFilterer<TEntity> 
    where TEntity : class, IEntity
{
    void AddGlobalFilters(List<FilterDefinition<TEntity>> filters);
}

public interface IMongoDbRepositoryFilterer<TEntity, TKey> : 
	IMongoDbRepositoryFilterer<TEntity> 
        where TEntity : class, IEntity<TKey>
{
    FilterDefinition<TEntity> CreateEntityFilter(
        TKey id, 
        bool applyFilters = false);
    
    FilterDefinition<TEntity> CreateEntityFilter(
        TEntity entity, 
        bool withConcurrencyStamp = false, 
        string concurrencyStamp = null);
}

```

###### 2.2.4.2 MongoDbRepositoryFilter(TEntity)

```c#
public class MongoDbRepositoryFilterer<TEntity> : 
	IMongoDbRepositoryFilterer<TEntity>        
        where TEntity : class, IEntity
{
    protected IDataFilter DataFilter { get; }    
    protected ICurrentTenant CurrentTenant { get; }    
    public MongoDbRepositoryFilterer(
        IDataFilter dataFilter, 
        ICurrentTenant currentTenant)
    {
        DataFilter = dataFilter;
        CurrentTenant = currentTenant;
    }
    
    public virtual void AddGlobalFilters(
        List<FilterDefinition<TEntity>> filters)
    {
        if (typeof(ISoftDelete).IsAssignableFrom(typeof(TEntity)) && 
            DataFilter.IsEnabled<ISoftDelete>())
        {
            filters.Add(
                Builders<TEntity>.Filter.Eq(
                    e => ((ISoftDelete) e).IsDeleted,                                       false));
        }
        
        if (typeof(IMultiTenant).IsAssignableFrom(typeof(TEntity)))
        {
            var tenantId = CurrentTenant.Id;
            filters.Add(
                Builders<TEntity>.Filter.Eq(
                    e => ((IMultiTenant) e).TenantId, 
                    tenantId));
        }
    }
}

```

###### 2.2.4.3 MongoDbRepositoryFilter(TEntity, TKey)

```c#
public class MongoDbRepositoryFilterer<TEntity, TKey> 
    : MongoDbRepositoryFilterer<TEntity>,        
	  IMongoDbRepositoryFilterer<TEntity, TKey>        
          where TEntity : class, IEntity<TKey>
{
    public MongoDbRepositoryFilterer(
        IDataFilter dataFilter, 
        ICurrentTenant currentTenant)            
        	: base(dataFilter, currentTenant)
    {
    }
    
    public FilterDefinition<TEntity> CreateEntityFilter(
        TKey id, 
        bool applyFilters = false)
    {
        var filters = new List<FilterDefinition<TEntity>>
        {
            Builders<TEntity>.Filter.Eq(e => e.Id, id)
        };
        
        if (applyFilters)
        {
            AddGlobalFilters(filters);
        }
        
        return Builders<TEntity>.Filter.And(filters);
    }
    
    public FilterDefinition<TEntity> CreateEntityFilter(
        TEntity entity, 
        bool withConcurrencyStamp = false, 
        string concurrencyStamp = null)
    {
        if (!withConcurrencyStamp || 
            !(entity is IHasConcurrencyStamp entityWithConcurrencyStamp))
        {
            return Builders<TEntity>.Filter.Eq(e => e.Id, entity.Id);
        }
        
        if (concurrencyStamp == null)
        {
            concurrencyStamp = entityWithConcurrencyStamp.ConcurrencyStamp;
        }
        
        return Builders<TEntity>.Filter.And(
            Builders<TEntity>.Filter.Eq(
                e => e.Id, 
                entity.Id),
            Builders<TEntity>.Filter.Eq(
                e => ((IHasConcurrencyStamp) e).ConcurrencyStamp, 
                concurrencyStamp)            );
    }
}

```

#### 2.3 abp mongo db context

* mongodb 的抽象映射
* 隔离 repo 和 mongodb
* 定义数据模型

##### 2.3.1 接口

```c#
public interface IAbpMongoDbContext
{
    // 包裹 mongodb driver 中的组件    
    IMongoClient Client { get; }    
    IMongoDatabase Database { get; }          
    IClientSessionHandle SessionHandle { get; }       
    
    // 解析数据表
    IMongoCollection<T> Collection<T>();  
}

```

##### 2.3.2 实现

```c#
public abstract class AbpMongoDbContext : 
	IAbpMongoDbContext, 
	ITransientDependency
{                 
    public IMongoClient Client { get; private set; }    
    public IMongoDatabase Database { get; private set; }    
    public IClientSessionHandle SessionHandle { get; private set; }
    
    // abp框架定义的 mongodb model    
    public IMongoModelSource ModelSource { get; set; } 
            
    // 初始化 mongodb database    
    public virtual void InitializeDatabase(
        IMongoClient client, 
        IMongoDatabase database,         
        IClientSessionHandle sessionHandle)
    {
        // 注入 client、database、sessionHandle
        Client = client;
        Database = database;        
        SessionHandle = sessionHandle;
    }
    
    // 初始化 mongodb collections，    
    public virtual void InitializeCollections(IMongoDatabase database)
    {
        // 注入 mongodb database
        Database = database;
        // 创建 mongodb source model
        ModelSource.GetModel(this);
    }
    
    // 获取 mongodb collection 
    public virtual IMongoCollection<T> Collection<T>()
    {
        // 从 mongodb database 获取 mongobd collection<T>
        return Database.GetCollection<T>(GetCollectionName<T>());
    }
        
    // 获取 mongodb collection name
    protected virtual string GetCollectionName<T>()
    {
        // 从 mongodb entity model 获取 collection name
        return GetEntityModel<T>().CollectionName;
    }
    
    // 获取 mongodb entity model
    protected virtual IMongoEntityModel GetEntityModel<TEntity>()
    {
        // 获取 TEntity 对应的 mongodb entity model
        var model = ModelSource.GetModel(this).Entities
            .GetOrDefault(typeof(TEntity));
        
        // 如果没有对应 entity model，抛出异常
        if (model == null)
        {
            throw new AbpException(
                "Could not find a model for given entity type: " + 
                typeof(TEntity).AssemblyQualifiedName);
        }
        
        return model;
    }
    
    // 创建 mongo model，
    // 在派生类中实现
    protected internal virtual void CreateModel(
        IMongoModelBuilder modelBuilder)
    {        
    }
}

```

#### 2.4 mongodb model

##### 2.4.1 mongo dbContext model

* 代表 mongodb database

* 包含 mongodb entity 集合，即 mongodb 中的 collection

```c#
public class MongoDbContextModel
{
    // entity 集合，即 mongodb 中的 collection
    public IReadOnlyDictionary<Type, IMongoEntityModel> Entities { get; }
    
    public MongoDbContextModel(
        IReadOnlyDictionary<Type, IMongoEntityModel> entities)
    {
        Entities = entities;
    }
}

```

##### 2.4.2 mongodb model source

* 管理 mongo dbContext model
* 缓存 mongo dbContext model

###### 2.4.2.1 接口

```c#
public interface IMongoModelSource
{
    MongoDbContextModel GetModel(AbpMongoDbContext dbContext);
}

```

###### 2.4.2.2 实现

* 创建 mongo dbContext model builder
* 由 dbContext 类型构建 entities
  * 根据 mongodb collection <T> 的泛型类型创建
* 由 dbContext 实例构建 entities
  * 调用 mongo dbContext 中重写的 create_model 方法，
  * 可以在根据类型构建 entities 重配置
* 创建 mongo dbContext model

```c#
public class MongoModelSource : 
	IMongoModelSource, 
	ISingletonDependency
{
    // 存储 mongo dbContext model 的容器，
    // mongo dbContext 类型为索引
    protected readonly ConcurrentDictionary<Type, MongoDbContextModel> ModelCache = new ConcurrentDictionary<Type, MongoDbContextModel>();
    
    // 根据 TMongoDbContext 类型解析（缓存） mongo dbContext model
    public virtual MongoDbContextModel GetModel(
        AbpMongoDbContext dbContext)
    {
        return ModelCache.GetOrAdd(
            dbContext.GetType(),
            _ => CreateModel(dbContext));
    }
    
    // 创建 TMongoDbContext 类型为索引的 mongo dbContext model
    protected virtual MongoDbContextModel CreateModel(
        AbpMongoDbContext dbContext)
    {
        // a- 创建 mongo dbContext model builder
        var modelBuilder = CreateModelBuilder();
        // b- 根据 mongo dbContext 类型构建 entities
        BuildModelFromDbContextType(modelBuilder, dbContext.GetType());
        // c- 根据 mongo dbContext 实例构建 entities
        BuildModelFromDbContextInstance(modelBuilder, dbContext);
        // d- 创建 mongo dbContext model
        return modelBuilder.Build(dbContext);
    }
    
    // a- 创建 mongo dbContext model builder
    protected virtual MongoModelBuilder CreateModelBuilder()
    {
        return new MongoModelBuilder();
    }
    
    // b- 根据 mongo dbContext 类型构建 entities
    protected virtual void BuildModelFromDbContextType(
        IMongoModelBuilder modelBuilder, 
        Type dbContextType)
    {
        // 遍历所有 property
        var collectionProperties =
            from 
            	// public、instance
            	property in dbContextType.GetTypeInfo()
            		.GetProperties(
            			BindingFlags.Public | 
            			BindingFlags.Instance)
            where
            	// 实现了 IMongoCollection<T>
            	ReflectionHelper.IsAssignableToGenericType(
            		property.PropertyType, 
            		typeof(IMongoCollection<>)) &&
            	// T 实现了 IEntity
            	typeof(IEntity).IsAssignableFrom(
            		property.PropertyType.GenericTypeArguments[0])
            select property;
        
        foreach (var collectionProperty in collectionProperties)
        {
            // 由上述 property 创建 mongo dbContext model 中的 entity
            BuildModelFromDbContextCollectionProperty(
                modelBuilder, 
                collectionProperty);
        }
    }
    
    // 根据 property info 创建 mongo dbContext entity model
    protected virtual void BuildModelFromDbContextCollectionProperty(
        IMongoModelBuilder modelBuilder, 
        PropertyInfo collectionProperty)
    {
        // 获取 collection 对应的 entity 类型
        var entityType = collectionProperty
            .PropertyType
            .GenericTypeArguments[0];
        
        // 获取 collection attribute
        var collectionAttribute = collectionProperty
            .GetCustomAttributes()
            .OfType<MongoCollectionAttribute>()
            .FirstOrDefault();
        
        // 创建 entity 并存储
        modelBuilder.Entity(
            entityType, 
            b => {
                b.CollectionName = collectionAttribute
                    ?.CollectionName ?? collectionProperty.Name;
            });
    }
            
    // c- 根据 mongo dbContext 实例构建 entities，
    // 调用 mongo dbContext 的 create_model 方法
    protected virtual void BuildModelFromDbContextInstance(
        IMongoModelBuilder modelBuilder, 
        AbpMongoDbContext dbContext)
    {
        dbContext.CreateModel(modelBuilder);
    }
}

```

##### 2.4.3 mongodb model builder

* dbContext model 构造器

###### 2.4.3.1 接口

```c#
public interface IMongoModelBuilder
{
    void Entity<TEntity>(
        Action<IMongoEntityModelBuilder<TEntity>> buildAction = null);
    
    void Entity(
        [NotNull] Type entityType, 
        Action<IMongoEntityModelBuilder> buildAction = null);
    
    IReadOnlyList<IMongoEntityModel> GetEntities();
}

```

###### 2.4.3.2 实现

* 构建并存储 entity model 的方法
* 构建 dbContext model

```c#
public class MongoModelBuilder : IMongoModelBuilder
{
    // 创建 entity model 容器
    private readonly Dictionary<Type, object> _entityModelBuilders;            
    public MongoModelBuilder()
    {
        _entityModelBuilders = new Dictionary<Type, object>();
    }
    
    // 构建并存储 TEntity 对应的 mongo entity model
    // 泛型方法
    public virtual void Entity<TEntity>(
        Action<IMongoEntityModelBuilder<TEntity>> buildAction = null)
    {
        var model = (IMongoEntityModelBuilder<TEntity>)_entityModelBuilders
            .GetOrAdd(
            	typeof(TEntity),
            	() => new MongoEntityModelBuilder<TEntity>());
        
        buildAction?.Invoke(model);
    }
    
    // 构建并存储 entity 对应的 mongo entity model
    public virtual void Entity(
        Type entityType, 
        Action<IMongoEntityModelBuilder> buildAction = null)
    {
        Check.NotNull(entityType, nameof(entityType));
        
        var model = (IMongoEntityModelBuilder)_entityModelBuilders
            .GetOrAdd(
            	entityType,
            	() => (IMongoEntityModelBuilder)Activator
            		.CreateInstance(
                        typeof(MongoEntityModelBuilder<>)
                        	.MakeGenericType(entityType)));
        
        buildAction?.Invoke(model);
    }
    
    public virtual IReadOnlyList<IMongoEntityModel> GetEntities()
    {
        return _entityModelBuilders
            .Values
            .Cast<IMongoEntityModel>()
            .ToImmutableList();
    }
    
    // 构建 dbContext model，
    // 使用锁
    private static readonly object SyncObj = new object();
    public MongoDbContextModel Build(AbpMongoDbContext dbContext)
    {
        lock (SyncObj)
        {
            // 将存储的 entity model 转换为
            // （entity type, IMongoEntityModel）的不变集合
            var entityModels = _entityModelBuilders
                .Select(x => x.Value)
                .Cast<IMongoEntityModel>()
                .ToImmutableDictionary(x => x.EntityType, x => x);
            
            var baseClasses = new List<Type>();
            
            foreach (var entityModel in entityModels.Values)
            {
                // 获取 entity model 的 bson_class_map，
                // 因为 object 同时实现了 IHasBsonClassMap 接口
                var map = entityModel.As<IHasBsonClassMap>().GetMap();
                // 注册 bson_class_map
                if (!BsonClassMap.IsClassMapRegistered(map.ClassType))
                {
                    BsonClassMap.RegisterClassMap(map);
                }
                
                // 获取 entity model 对应 entity type 的所有基类
                baseClasses.AddRange(
                    entityModel
                    	.EntityType
                    	.GetBaseClasses(includeObject: false));
                
                // 创建 entity model 对应的 collection
                CreateCollectionIfNotExists(
                    dbContext, 
                    entityModel.CollectionName);
            }
            
            // 基类去重
            baseClasses = baseClasses.Distinct().ToList();
            
            foreach (var baseClass in baseClasses)
            {
                // 注册 entity model 的 entity type 的 基类 的 bson_class_map
                if (!BsonClassMap.IsClassMapRegistered(baseClass))
                {
                    // 创建 baseClass 的 bsonClassMap
                    var map = new BsonClassMap(baseClass);
                    // 配置apb convention，即 extra properties
                    map.ConfigureAbpConventions();
                    // 注册 bsonClassMap
                    BsonClassMap.RegisterClassMap(map);
                }
            }
            
            return new MongoDbContextModel(entityModels);
        }
    }
    
    // 在 mongodb database 中创建 collection            
    protected virtual void CreateCollectionIfNotExists(
        AbpMongoDbContext dbContext, 
        string collectionName)
    {
        var filter = new BsonDocument("name", collectionName);
        var options = new ListCollectionNamesOptions { Filter = filter };
        
        if (!dbContext.Database.ListCollectionNames(options).Any())
        {
            dbContext.Database.CreateCollection(collectionName);
        }
    }
}

```

###### 2.4.3.3 bson class map abp convention

```c#
public static class AbpBsonClassMapExtensions
{
    public static void ConfigureAbpConventions(this BsonClassMap map)
    {
        // mongodb drive 的自动匹配
        map.AutoMap();
        // 匹配 abp extra properties
        map.TryConfigureExtraProperties();
    }        
    
    public static bool TryConfigureExtraProperties(this BsonClassMap map)
    {
        // 如果 class type（entity type）不支持 extra property，False
        if (!map.ClassType.IsAssignableTo<IHasExtraProperties>())
        {
            return false;
        }
        
        // 获取 extra properties 属性中的
        // public、instance 属性
        var property = map.ClassType.GetProperty(
            nameof(IHasExtraProperties.ExtraProperties),
            BindingFlags.Public | 
            BindingFlags.Instance | 
            BindingFlags.GetProperty);
        
        // property 声明类型与 map.classType 不同
        // 比如 property 为 null
        if (property?.DeclaringType != map.ClassType)
        {
            return false;
        }
        
        // 使用 mongodb drive 的 set extra elements 方法
        map.MapExtraElementsMember(property);
        
        return true;
    }
    
    public static bool TryConfigureExtraProperties<TEntity>(
        this BsonClassMap<TEntity> map)     
        	where TEntity : class, IHasExtraProperties
    {        
        var property = map.ClassType.GetProperty(
            nameof(IHasExtraProperties.ExtraProperties),
            BindingFlags.Public | 
            BindingFlags.Instance | 
            BindingFlags.GetProperty);
                
        if (property?.DeclaringType != map.ClassType)
        {
            return false;
        }
                
        map.SetExtraElementsMember(
            new BsonMemberMap(
                map,
                typeof(TEntity).GetMember(
                    nameof(IHasExtraProperties.ExtraProperties))[0]));
        
        return true;
    }
}

```

#### 2.5 mongodb entity model

##### 2.5.1 has bson class map

```c#
public interface IHasBsonClassMap
{
    BsonClassMap GetMap();
}

```

##### 2.5.2 mongodb entity model

* 代表 mongodb collection

```c#
public interface IMongoEntityModel
{
    Type EntityType { get; }    
    string CollectionName { get; }
}

```

##### 2.5.3 mongodb entity model builder

###### 2.5.3.1 接口

```c#
public interface IMongoEntityModelBuilder
{
    Type EntityType { get; }    
    string CollectionName { get; set; }    
    BsonClassMap BsonMap { get; }
}

public interface IMongoEntityModelBuilder<TEntity>
{
    Type EntityType { get; }    
    string CollectionName { get; set; }    
    BsonClassMap<TEntity> BsonMap { get; }
}
    
```

###### 2.5.3.2 实现

```c#
public class MongoEntityModelBuilder<TEntity> : 
	IMongoEntityModel,         
	IHasBsonClassMap,        
	IMongoEntityModelBuilder,       
	IMongoEntityModelBuilder<TEntity>
{
    // 实现 IMongoEntityModel 接口，
    // 实现 IMongoEntityModelBuilder
    public Type EntityType { get; }    
    public string CollectionName { get; set; }
    
    private readonly BsonClassMap<TEntity> _bsonClassMap;
        
    // 实现 IMongoEntityModelBuilder 接口
    BsonClassMap IMongoEntityModelBuilder.BsonMap => _bsonClassMap;
    BsonClassMap<TEntity> IMongoEntityModelBuilder<TEntity>.BsonMap => _bsonClassMap;
            
    public MongoEntityModelBuilder()
    {
        EntityType = typeof(TEntity);
        _bsonClassMap = new BsonClassMap<TEntity>();
        _bsonClassMap.ConfigureAbpConventions();
    }
    
    // 实现 IHasBsonClassMap 接口    
    public BsonClassMap GetMap()
    {
        return _bsonClassMap;
    }
}

```

#### 2.6 mongodb provider

##### 2.6.1 mongo dbContext provider 接口

```c#
public interface IMongoDbContextProvider<out TMongoDbContext>
    where TMongoDbContext : IAbpMongoDbContext
{
    TMongoDbContext GetDbContext();
}

```

##### 2.6.2 uow mongo dbContext provider

* 提供存储的 mongo dbContext
* 类似 manager 的角色

```c#
public class UnitOfWorkMongoDbContextProvider<TMongoDbContext> : 
	MongoDbContextProvider<TMongoDbContext>        
        where TMongoDbContext : IAbpMongoDbContext
{
    // 注入 uow、conn_string_resolver
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    private readonly IConnectionStringResolver _connectionStringResolver;    
    public UnitOfWorkMongoDbContextProvider(
        IUnitOfWorkManager unitOfWorkManager,
        IConnectionStringResolver connectionStringResolver)
    {
        _unitOfWorkManager = unitOfWorkManager;
        _connectionStringResolver = connectionStringResolver;
    }
    
    // 获取 dbContext    
    
    // 创建 dbContext
        
    // 创建 transaction dbContext    
}

```

###### 2.6.2.1 get mongo dbContext

```c#
public class UnitOfWorkMongoDbContextProvider<TMongoDbContext>
{
    public TMongoDbContext GetDbContext()
    {
        // 获取 current uow，
        // 如果没有，抛出异常
        var unitOfWork = _unitOfWorkManager.Current;
        if (unitOfWork == null)
        {
            throw new AbpException(
                $"A {nameof(IMongoDatabase)} instance can only be created inside a unit of work!");
        }
                
        // 解析 conn string
        var connectionString = _connectionStringResolver
            .Resolve<TMongoDbContext>();
        // 生成 dbContext key
        var dbContextKey = $"{typeof(TMongoDbContext).FullName}_{connectionString}";
        // 生成 mongodb url（连接字符串）
        var mongoUrl = new MongoUrl(connectionString);
        // 使用 conn string name 特性标记 mongodb database name
        var databaseName = mongoUrl.DatabaseName;
        if (databaseName.IsNullOrWhiteSpace())
        {
            databaseName = ConnectionStringNameAttribute
                .GetConnStringName<TMongoDbContext>();
        }
        
        // 获取 current uow 下的 mongo database api，
        // 如果没有，创建并添加
        var databaseApi = unitOfWork.GetOrAddDatabaseApi(
            dbContextKey,
            () => new MongoDbDatabaseApi<TMongoDbContext>(
                CreateDbContext(
                    unitOfWork, 
                    mongoUrl, 
                    databaseName)));
        
        // 返回 mongodb database api 中的 dbContext
        return ((MongoDbDatabaseApi<TMongoDbContext>) databaseApi)
            .DbContext;
    }
}

```

###### 2.6.2.2 create mongo dbContext

```c#
public class UnitOfWorkMongoDbContextProvider<TMongoDbContext>
{
    private TMongoDbContext CreateDbContext(
        IUnitOfWork unitOfWork, 
        MongoUrl mongoUrl, 
        string databaseName)
    {
        // 创建 mongodb client（mongodb driver）
        var client = new MongoClient(mongoUrl);
        // 从 client 解析 database（mongodb driver）
        var database = client.GetDatabase(databaseName);
        
        // 如果支持 transaction，
        // 创建 transaction dbContext
        if (unitOfWork.Options.IsTransactional)
        {
            return CreateDbContextWithTransaction(
                unitOfWork, mongoUrl, client, database);
        }
        
        // 从 service 解析 TMongoDbContext
        var dbContext = unitOfWork.ServiceProvider
            .GetRequiredService<TMongoDbContext>();
        // 初始化 mongo dbContext 中的 database
        dbContext.ToAbpMongoDbContext()
            .InitializeDatabase(database, client, null);
        
        return dbContext;
    }
}

```

###### 2.6.2.3 create transaction mongo dbContext

```c#
public class UnitOfWorkMongoDbContextProvider<TMongoDbContext>
{
    public TMongoDbContext CreateDbContextWithTransaction(
        IUnitOfWork unitOfWork,
        MongoUrl url,
        MongoClient client,
        IMongoDatabase database)
    {
        var transactionApiKey = $"MongoDb_{url}";
        var activeTransaction = unitOfWork
            .FindTransactionApi(transactionApiKey) as MongoDbTransactionApi;
        var dbContext = unitOfWork.ServiceProvider
            .GetRequiredService<TMongoDbContext>();
        
        if (activeTransaction?.SessionHandle == null)
        {
            var session = client.StartSession();
            
            if (unitOfWork.Options.Timeout.HasValue)
            {
                session.AdvanceOperationTime(
                    new BsonTimestamp(
                        unitOfWork.Options.Timeout.Value));
            }
            
            session.StartTransaction();
            
            unitOfWork.AddTransactionApi(
                transactionApiKey,
                new MongoDbTransactionApi(session));
            
            dbContext.ToAbpMongoDbContext()
                .InitializeDatabase(
                	database, client, session);
        }
        else
        {
            dbContext.ToAbpMongoDbContext()
                .InitializeDatabase(
                	database, client, activeTransaction.SessionHandle);
        }
        
        return dbContext;
    }
}

```

##### 2.6.3 database api

###### 2.6.3.1 mongodb database api

```c#
public class MongoDbDatabaseApi<TMongoDbContext> : IDatabaseApi
{
    public TMongoDbContext DbContext { get; }    
    public MongoDbDatabaseApi(TMongoDbContext dbContext)
    {
        DbContext = dbContext;
    }
}

```

###### 2.6.3.2 mongodb transaction api

```c#
public class MongoDbTransactionApi : ITransactionApi, ISupportsRollback
{
    public IClientSessionHandle SessionHandle { get; }    
    public MongoDbTransactionApi(IClientSessionHandle sessionHandle)
    {
        SessionHandle = sessionHandle;
    }
    
    protected void Commit()
    {
        SessionHandle.CommitTransaction();
    }
    
    public async Task CommitAsync()
    {
        await SessionHandle.CommitTransactionAsync();
    }
                    
    public void Rollback()
    {
        SessionHandle.AbortTransaction();
    }
    
    public async Task RollbackAsync(CancellationToken cancellationToken)
    {
        await SessionHandle.AbortTransactionAsync(cancellationToken);
    }
    
    public void Dispose()
    {
        SessionHandle.Dispose();
    }
}

```

#### 2.7 模块

```c#
[DependsOn(typeof(AbpDddDomainModule))]
public class AbpMongoDbModule : AbpModule
{
    public override void PreConfigureServices(
        ServiceConfigurationContext context)
    {
        context.Services.AddConventionalRegistrar(
            new AbpMongoDbConventionalRegistrar());
    }
    
    public override void ConfigureServices(
        ServiceConfigurationContext context)
    {
        // 注册 mongo dbContext provider
        context.Services.TryAddTransient(
            typeof(IMongoDbContextProvider<>),
            typeof(UnitOfWorkMongoDbContextProvider<>));
        
        /* 注册 mongodb repo filter */
        
        context.Services.TryAddTransient(
            typeof(IMongoDbRepositoryFilterer<>),
            typeof(MongoDbRepositoryFilterer<>));        
        
        context.Services.TryAddTransient(
            typeof(IMongoDbRepositoryFilterer<,>),
            typeof(MongoDbRepositoryFilterer<,>));
    }
}

```

### 3. practice

#### 3.1 定义 mongo dbContext

* 定义数据库模型

```c#
public class MyDbContext : AbpMongoDbContext
{
    // 手动声明 collection
    public IMongoCollection<Question> Questions => Collection<Question>();
    public IMongoCollection<Category> Categories => Collection<Category>();

    // 重写 create model 方法，
    // 会在默认 create model 方法后执行，可用于 model 定制化
    protected override void CreateModel(IMongoModelBuilder modelBuilder)
    {
        base.CreateModel(modelBuilder);

        //Customize the configuration for your collections.
    }
}

```

##### 3.1.1 填充 mongodb collection

* collection<T> 对应 IRepo<T>

##### 3.1.2 自动 map collection

* 默认使用 mongodb driver 的 automap 方法自动匹配 collection 和 entity type

* 不需要手动 map

##### 3.1.3 手动 map collection

* 可以手动 map collection，用于定制化

```c#
protected override void CreateModel(IMongoModelBuilder modelBuilder)
{
    base.CreateModel(modelBuilder);

    modelBuilder.Entity<Question>(b =>
    {
        // Sets the collection name
        b.CollectionName = "MyQuestions"; 
        // Ignores 'MyProperty'
        b.BsonMap.UnmapProperty(x => x.MyProperty); 
    });
}

```

#### 3.2 mongodb 连接

##### 3.2.1 conn string name

* 使用 conn string name 特性标记 mongo dbContext
* conn string name 同时也是对应的 mongodb database name

```c#
[ConnectionStringName("MySecondConnString")]
public class MyDbContext : AbpMongoDbContext
{
    // ...
}

```

##### 3.2.2 解析 conn string

* 使用 conn string resolver 解析
* 在`IConfiguration`配置

```json
"ConnectionStrings": {
    "Default": 
    	"Server=localhost;Database=MyMainDb;Trusted_Connection=True;",
    "AbpIdentityServer": 
    	"Server=localhost;Database=MyIdsDb;Trusted_Connection=True;",
    "AbpPermissionManagement": 
    	"Server=localhost;Database=MyPermissionDb;Trusted_Connection=True;"
}

```

#### 3.3 注册 mongo dbContext

##### 3.3.1 在 services 中注册

```c#
[DependsOn(typeof(AbpMongoDbModule))]
public class MyModule : AbpModule
{
    public override void ConfigureServices(
        ServiceConfigurationContext context)
    {
        context.Services.AddMongoDbContext<MyDbContext>();
        
        //...
    }
}

```

##### 3.3.2 注册 default repo

* 默认注册 aggregate 

```c#
services.AddMongoDbContext<MyDbContext>(options =>
{
    options.AddDefaultRepositories();
});

```

##### 3.3.3 注册 custom repo

```c#
context.Services.AddMongoDbContext<BookStoreMongoDbContext>(options =>
{    
    options.AddRepository<Book, BookRepository>(); 
});

```

#### 3.4 使用 mongodb repo

* 在 domain（services / application）注入 IRepo